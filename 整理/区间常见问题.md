区间常见问题：

$tips:$但$query$非常大的时候，离线处理可能会有较好的时间优化。



==1.区间因数和。==

当$query$很大，考虑预处理前缀和$pre[i]$,然后用$pre[r]-pre[l-1]=ans$

方法是：类比素数筛，可叫作因数筛。

```C++
 int n=1e6;
    for(reg int i=1;i<=n;i++)
        for(reg int j=i;j<=n;j+=i)
            a[j]+=i;
    for(reg int i=1;i<=n;i++) a[i]+=a[i-1];
```

2.数论做法.单次复杂度：$O(\sqrt{n})$，适用于询问数量小，但区间范围大的情况，

如$[1,1e12]$





==2.求区间和不能被$x$整除的最大区间长度。==

$tips:$答案只能是前缀和或后缀和，删除和为$x$的倍数前缀和后缀不会影响$x$整除性。

首先若$pre[n]\%x!=0\rightarrow ans=n$.

否则若存在可行解为删取某个前缀和某个后缀和后的区间。

则该前缀和与后缀和的和肯定不是$x$的倍数。

说明存在一个前缀或后缀不是$x$的倍数，即只用删除这个前缀或者后缀即可。 

即答案肯定是前缀或者后缀，同时我们直接一遍输入一遍取最大值。

当前缀满足时，直接取前缀和后缀长度的最大值，这里为什么我们没有求后缀就能取呢？因为如果后缀不是$x$的倍数，那么答案就是$pre[n]$.后来会被更新掉，否则答案就可以被它更新。

时间复杂度:$O(n)$

重点式子：

```C++
if(sum%x)
  ans=max({ans,i,n-i});
```

思考题：==.求区间和能被$x$整除的最大区间长度。==

按照上面的思路再来考虑一波，如果$pre[n]\%x==0,ans=n$.

否则存在一个删去前缀和后缀的解，前缀和后缀的和不是$x$的倍数，

则肯定存在一个前缀或者后缀不是$x$的倍数，则只用删去这一个即可。

但是这里不能边读边比较，因为若前缀能被整除，不能保证后缀能被整除，如果后缀能被整除，肯定会被更新，但是不能被整除就不行。前缀不能被整除，后缀有可能能被整除。所以要预处理前缀和后缀，再进行取最值。

时间复杂度:$O(2n)$

$ep:[3,7,7],x=7$,显然答案为$2$,但是取前缀答案为$0$.

